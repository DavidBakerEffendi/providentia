\tilo{This paper tackles} the problem of modelling, visualizing, and querying large-scale spatio-temporal data using traditional relational database approaches versus graph database \tilo{approaches}. 
\tilo{We investigate} query performance, storage and computational cost, \tilo{as well} ease and efficiency of simulation of real-world applications. \tilo{In particular,\dots}

\tilo{\textit{How to store spatio-temporal data efficiently?}} Coordinates are comprised of latitude and longitude and time adds a third dimension. The accessing times of secondary storage is an issue when housing large volumes of data. The use of B-Trees, R-Trees, and a geo-graph\footnote{A grid-based geospatial system where vertices are grids and edges connect other vertices to these grid vertices to indicate their physical location.} are three techniques investigated for indexing \tilo{both,} uni- and multidimensional data efficiently.

\tilo{\textit{How to query a graph topology effectively?}} Basic graph pattern matching is popular \tilo{when extracting} data from graph databases, but there are a range of graph query languages \tilo{implementing} more complex graph patterns, \tilo{too}. Section \ref{sec:graphLang} addresses three graph querying languages namely; Gremlin, Cypher, and GSQL. \tilo{This section will also cover how traditional relational operators, such as union and difference, are implemented in graph pattern matching}. The conciseness of querying graphs versus using traditional SQL is \tilo{briefly addressed} in the conclusion (Section \ref{sec:conclusion})\footnote{To effectively measure the difficulty of learning and writing complex queries would require experiments involving developers new to these languages and measuring their progress in terms of error rates, which is clearly beyond the scope of this paper.}.

\tilo{\textit{Can the respective database components be easily integrated into applications?}} Due to the rise of popularity in web-based applications, the ease of incorporating three \tilo{typical} databases \tilo{into applications} will be investigated with a Flask \cite{flask} back-end and Angular \cite{angular} driven front-end. This will show how appropriate it is in real-world applications and production settings to use graph database technologies and any challenges encountered during implementation versus using a classical SQL database back-end.
